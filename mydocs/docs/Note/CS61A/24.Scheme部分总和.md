# Schemeéƒ¨åˆ†æ€»å’Œ

è¯¾ç¨‹åœ¨è®²è§£Schemeçš„è¿‡ç¨‹ä¸­æ¼”ç¤ºäº†å¤§é‡çš„`py`æ–‡ä»¶ï¼Œä¸»é¡µä¸Šå¯ä»¥ä¸‹è½½è¿™äº›è¯¾ç¨‹ä¸­å‡ºç°çš„æ–‡ä»¶ï¼Œä»£ç é‡æ„Ÿè§‰è¿˜æŒºå¤šï¼Œäºæ˜¯å‡†å¤‡å¯¹è¿™ä¸ªå°å‹çš„Pythoné¡¹ç›®è¿›è¡Œç ”è¯»åˆ†æ

> è¯¢é—®äº†GPT-4oï¼Œä»–ç»™å‡ºçš„é˜…è¯»å»ºè®®æ˜¯ï¼š
>
> é˜…è¯»é¡¹ç›®çš„ä»£ç æ—¶ï¼Œé€šå¸¸éµå¾ªä»æ•´ä½“åˆ°å±€éƒ¨çš„åŸåˆ™ï¼Œå…ˆäº†è§£é¡¹ç›®çš„æ•´ä½“ç»“æ„å’Œä¸»è¦åŠŸèƒ½æ¨¡å—ï¼Œç„¶åé€æ­¥æ·±å…¥åˆ°å„ä¸ªæ¨¡å—çš„å…·ä½“å®ç°ç»†èŠ‚ã€‚å¯¹äºè¿™ä¸ªé¡¹ç›®ï¼Œæˆ‘å»ºè®®æŒ‰ç…§ä»¥ä¸‹é¡ºåºé˜…è¯»ï¼š
>
> 1. **`ucb.py`**
> 2. **`buffer.py`**
> 3. **`scheme_tokens.py`**
> 4. **`scheme_reader.py`**
> 5. **`scalc.py`**
>
> å…¶ä¸­å®ƒå¼ºè°ƒè¦ç€é‡å…³æ³¨`scalc.py`ï¼Œè¿™æ˜¯è¯¥é¡¹ç›®çš„æ ¸å¿ƒ

## buffer.py

`buffer.py` æ–‡ä»¶å®šä¹‰äº† `Buffer` å’Œ `InputReader` ç±»ï¼Œè¿™ä¸¤ä¸ªç±»åœ¨é¡¹ç›®ä¸­è´Ÿè´£å¤„ç†è¾“å…¥çš„ç¼“å†²å’Œè¯»å–ã€‚

```python linenums="1" hl_lines="23-33 12-17"
import math

class Buffer(object):
   
    def __init__(self, source):
        self.index = 0
        self.lines = []
        self.source = source
        self.current_line = ()
        self.current()
        
    def pop(self):
        """Remove the next item from self and return it. If self has
        exhausted its source, returns None."""
        current = self.current()
        self.index += 1
        return current

    @property
    def more_on_line(self):
        return self.index < len(self.current_line)

    def current(self):
        """Return the current element, or None if none exists."""
        while not self.more_on_line:
            self.index = 0
            try:
                self.current_line = next(self.source)
                self.lines.append(self.current_line)
            except StopIteration:
                self.current_line = ()
                return None
        return self.current_line[self.index]
```

è¦æ³¨æ„çš„æ˜¯`current`æ–¹æ³•ï¼Œä»–çš„é€»è¾‘æ˜¯ï¼šå…ˆæ£€æŸ¥å½“å‰è¡Œè¿˜æœ‰æ²¡æœ‰å…ƒç´ ï¼Œæœ‰å…ƒç´ å°±ç›´æ¥è¿”å›å½“å‰å…ƒç´ ï¼Œæ²¡æœ‰å…ƒç´ å°±è¯´æ˜è¯¥è¡Œå·²ç»è¯»å–å®Œï¼Œäºæ˜¯è¿›å…¥`while`å¾ªç¯ï¼Œå³å¼€å§‹å‡†å¤‡ä¸‹ä¸€è¡Œçš„è¯»å–ï¼ˆé‡ç½®`index`ã€å°†æ–°è¯»å–çš„è¡Œå­˜å…¥`lines`ï¼‰ï¼Œæ³¨æ„`while`å¾ªç¯ä¸­é‡‡ç”¨äº†`try`æ¥é˜²æ­¢ç¨‹åºä¸­æ–­ï¼ˆå½“å‰è¡Œæ²¡æœ‰`next`æ—¶è¿”å›`None`ï¼‰

`pop`æ–¹æ³•åº”è¯¥æ˜¯å’Œ`current`ååŒä½¿ç”¨

```python
class InputReader(object):
    """An InputReader is an iterable that prompts the user for input."""
    def __init__(self, prompt):
        self.prompt = prompt

    def __iter__(self):
        while True:
            yield input(self.prompt)
            self.prompt = ' ' * len(self.prompt)
```

å®šä¹‰äº†ä¸€ä¸ªåä¸º `InputReader` çš„ç±»ï¼Œå®ƒçš„ä½œç”¨æ˜¯åˆ›å»ºä¸€ä¸ªå¯è¿­ä»£å¯¹è±¡ï¼Œèƒ½å¤Ÿåœ¨è¿­ä»£è¿‡ç¨‹ä¸­ä¸æ–­æç¤ºç”¨æˆ·è¾“å…¥ã€‚

## scheme_tokens.py

è¿™ä¸ªæ¨¡å—çš„ä¸»è¦åŠŸèƒ½æ˜¯å°†è¾“å…¥å­—ç¬¦ä¸²æˆ–å­—ç¬¦ä¸²åºåˆ—è½¬æ¢ä¸º Scheme è¯­è¨€ä¸­çš„æ ‡è®°åˆ—è¡¨ã€‚é€šè¿‡ä½¿ç”¨ä¸€ç³»åˆ—å­—ç¬¦é›†å’Œè¾…åŠ©å‡½æ•°ï¼Œå®ƒèƒ½å¤Ÿè¯†åˆ«å¹¶å¤„ç†ä¸åŒç±»å‹çš„æ ‡è®°ï¼ŒåŒ…æ‹¬æ•°å­—ã€å¸ƒå°”å€¼ã€ç¬¦å·å’Œåˆ†éš”ç¬¦ã€‚

## scheme_reader.py

```python linenums="1" hl_lines="11 12"
class Pair(object):
    
    ...
    
    def __str__(self):
        s = "(" + str(self.first)
        second = self.second
        while isinstance(second, Pair):
            s += " " + str(second.first)
            second = second.second
        if second is not nil:
            s += " . " + str(second)
        return s + ")"
```

`str`ä¸­è¿™ä¸ªç‚¹æˆ‘æ²¡æ˜ç™½æ˜¯ä»€ä¹ˆï¼Œè¯¢é—®GPT-4oå¾—åˆ°ç­”å¤ï¼Œå½“`second`ä¸æ˜¯ `nil`ä¹Ÿä¸æ˜¯`Pair`æ—¶ï¼š

```python
nil = None  # å‡è®¾ nil æ˜¯ None

# åˆ›å»ºä¸€ä¸ª Pair å¯¹è±¡ï¼Œå…¶ä¸­ second æ˜¯ä¸€ä¸ªéç©ºä¸”é Pair å¯¹è±¡
p2 = Pair(1, Pair(2, 3))
print(p2)
```

è¾“å‡ºç»“æœï¼š

```python
(1 2 . 3)
```

> `__str__` æ–¹æ³•åœ¨å¤„ç† `Pair` å¯¹è±¡æ—¶ï¼Œå¦‚æœ `second` ä¸æ˜¯ `nil` ä¹Ÿä¸æ˜¯ `Pair`ï¼Œåˆ™åœ¨ç»“æœå­—ç¬¦ä¸²ä¸­ç”¨ç‚¹å·åˆ†éš”ç¬¦æ˜¾ç¤º `second` çš„å­—ç¬¦ä¸²è¡¨ç¤ºã€‚**è¿™ä¸ Lisp ä¸­çš„ç‚¹å¯¹ï¼ˆdotted pairï¼‰è¯­æ³•ä¸€è‡´ï¼Œå¸®åŠ©è¡¨ç¤ºé“¾è¡¨æœ«å°¾çš„é `nil` å€¼ã€‚**

```python
	def __len__(self):
        n, second = 1, self.second
        while isinstance(second, Pair):
            n += 1
            second = second.second
        if second is not nil:
            raise TypeError("length attempted on improper list")
        return n

    def __getitem__(self, k):
        if k < 0:
            raise IndexError("negative index into list")
        y = self
        for _ in range(k):
            if y.second is nil:
                raise IndexError("list index out of bounds")
            elif not isinstance(y.second, Pair):
                raise TypeError("ill-formed list")
            y = y.second
        return y.first
```

è¿™é‡Œå®ç°äº†è·å–é“¾è¡¨é•¿åº¦å’Œè·å–æŒ‡å®šç´¢å¼•çš„å…ƒç´ çš„åŠŸèƒ½ï¼ˆå®ç°äº†`__getitem__`åå°±å¯ä»¥é€šè¿‡`link[index]`ç›´æ¥è®¿é—®`link`ä¸­ç´¢å¼•ä¸º`index`çš„å…ƒç´ äº†ï¼‰

```python
def map(self, fn):
    """Return a Scheme list after mapping Python function FN to SELF."""
    mapped = fn(self.first)
    if self.second is nil or isinstance(self.second, Pair):
        return Pair(mapped, self.second.map(fn))
    else:
        raise TypeError("ill-formed list")
```

**å°æ’æ›²**ï¼šä¹‹å‰ä¸€ç›´ä¸ç†è§£ä¸ºä»€ä¹ˆè¦å–`map`è¿™ä¸ªåå­—ï¼ŒæŸ¥é˜…å­—å…¸åå‘ç°mapæœ‰æ˜ å°„ä¹‹æ„ğŸ˜‚

`map`æ–¹æ³•ä¼šå¯¹é“¾è¡¨ä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ éƒ½æ‰§è¡Œ`fn`ï¼ˆå°†å‡½æ•°åº”ç”¨äºä¸€ä¸ªé›†åˆï¼ˆå¦‚åˆ—è¡¨ï¼‰ä¸­çš„æ¯ä¸ªå…ƒç´ ï¼Œç”Ÿæˆä¸€ä¸ªæ–°é›†åˆï¼‰

>  åœ¨`scals.py`çš„`calc_eval`æ–¹æ³•ä¸­ï¼š`arguments = exp.second.map(calc_eval)`

åœ¨è¿™æ®µä»£ç ä¸­ï¼Œ`scheme_read` å‡½æ•°æ˜¯ä¸€ä¸ªç”¨äºä»æºï¼ˆ`Buffer` å¯¹è±¡ï¼‰ä¸­è¯»å– Scheme è¡¨è¾¾å¼çš„å‡½æ•°ã€‚å®ƒçš„ä¸»è¦åŠŸèƒ½æ˜¯è§£æ Scheme è¡¨è¾¾å¼çš„ç»“æ„ï¼Œå¹¶å°†å…¶è½¬æ¢ä¸ºç›¸åº”çš„ Python å¯¹è±¡ã€‚ä¸‹é¢è¯¦ç»†è§£é‡Š `scheme_read` å‡½æ•°åŠå…¶ç›¸å…³çš„ `read_tail` å‡½æ•°ã€‚

### æ ¸å¿ƒå‡½æ•°

> **`scheme_read`** å‡½æ•°è´Ÿè´£è§£æ Scheme è¡¨è¾¾å¼çš„ä¸åŒéƒ¨åˆ†ï¼šåŸå­å€¼ã€åˆ—è¡¨å’Œç©ºåˆ—è¡¨ã€‚**`read_tail`** å‡½æ•°ç”¨äºå¤„ç†åˆ—è¡¨ä¸­çš„å…ƒç´ ï¼Œå¹¶é€šè¿‡é€’å½’æ–¹å¼æ„é€ å‡ºå®Œæ•´çš„ Scheme åˆ—è¡¨ã€‚è¿™ä¸¤ä¸ªå‡½æ•°å…±åŒå·¥ä½œï¼Œå°† Scheme è¡¨è¾¾å¼è§£æä¸º Python å¯¹è±¡ï¼Œä½¿å¾—æˆ‘ä»¬å¯ä»¥åœ¨ Python ä¸­å¤„ç† Scheme è¡¨è¾¾å¼ã€‚

`scheme_read` å‡½æ•°çš„å®šä¹‰å¦‚ä¸‹ï¼š

```python
def scheme_read(src):
    """Read the next expression from src, a Buffer of tokens.

    >>> lines = ['(+ 1 ', '(+ 23 4)) (']
    >>> src = Buffer(tokenize_lines(lines))
    >>> print(scheme_read(src))
    (+ 1 (+ 23 4))
    """
    if src.current() is None:
        raise EOFError
    val = src.pop()
    if val == 'nil':
        return nil
    elif val not in DELIMITERS:  # ( ) ' .
        return val
    elif val == "(":
        return read_tail(src)
    else:
        raise SyntaxError("unexpected token: {0}".format(val))
```

æ³¨æ„åœ¨`doctest`ä¸­ï¼Œ`src = Buffer(tokenize_lines(lines))`å·²ç»å°†`lines`å¤„ç†æˆSchemeè¯­è¨€ä¸­çš„æ ‡è®°åˆ—è¡¨

å…¶æ‰§è¡Œé€»è¾‘ä¸ºï¼š

1. **æ£€æŸ¥æ–‡ä»¶ç»“æŸ**ï¼š
   - `if src.current() is None:` æ£€æŸ¥æºæ˜¯å¦å·²è¾¾åˆ°æ–‡ä»¶ç»“æŸã€‚å¦‚æœæ˜¯ï¼ŒæŠ›å‡º `EOFError`ã€‚

2. **è¯»å–ä¸‹ä¸€ä¸ªå€¼**ï¼š
   - `val = src.pop()` ä»æºä¸­è¯»å–ä¸‹ä¸€ä¸ªæ ‡è®°ï¼ˆtokenï¼‰ã€‚

3. **å¤„ç†ç‰¹å®šå€¼**ï¼š
   - `if val == 'nil':` å¦‚æœå€¼æ˜¯ `nil`ï¼Œè¿”å› `nil` å¯¹è±¡ï¼ˆç©ºåˆ—è¡¨ï¼‰ã€‚
   - `elif val not in DELIMITERS:` å¦‚æœå€¼ä¸æ˜¯åˆ†éš”ç¬¦ï¼ˆ`(`, `)`, `'`, `.`ï¼‰ï¼Œç›´æ¥è¿”å›è¿™ä¸ªå€¼ï¼ˆå®ƒå¯èƒ½æ˜¯ä¸€ä¸ªåŸå­æ ‡è®°ï¼Œå¦‚æ•°å­—æˆ–ç¬¦å·ï¼‰ã€‚
   - `elif val == "(":` å¦‚æœå€¼æ˜¯å·¦æ‹¬å· `(`ï¼Œè°ƒç”¨ `read_tail(src)` å‡½æ•°æ¥å¤„ç†åˆ—è¡¨ã€‚
   - `else:` å¯¹äºå…¶ä»–å€¼ï¼ŒæŠ›å‡º `SyntaxError`ï¼Œå› ä¸ºé‡åˆ°äº†æ„å¤–çš„æ ‡è®°ã€‚

`read_tail` å‡½æ•°çš„å®šä¹‰å¦‚ä¸‹ï¼š

```python
def read_tail(src):
   
    if src.current() is None:
        raise SyntaxError("unexpected end of file")
    if src.current() == ")":
        src.pop()
        return nil
    first = scheme_read(src)
    rest = read_tail(src)
    return Pair(first, rest)
```

æ‰§è¡Œé€»è¾‘ä¸ºï¼š

1. **æ£€æŸ¥æ–‡ä»¶ç»“æŸ**ï¼š
   - `if src.current() is None:` æ£€æŸ¥æºæ˜¯å¦è¾¾åˆ°æ–‡ä»¶ç»“æŸã€‚å¦‚æœæ˜¯ï¼ŒæŠ›å‡º `SyntaxError`ï¼Œè¡¨æ˜é‡åˆ°æ„å¤–çš„æ–‡ä»¶ç»“æŸã€‚
2. **å¤„ç†å³æ‹¬å·**ï¼š
   - `if src.current() == ")":` å¦‚æœå½“å‰æ ‡è®°æ˜¯å³æ‹¬å· `)`ï¼Œä»æºä¸­å¼¹å‡ºå®ƒå¹¶è¿”å› `nil`ï¼Œè¡¨ç¤ºåˆ—è¡¨çš„ç»“æŸã€‚
3. **è¯»å–å…ƒç´ **ï¼š
   - `first = scheme_read(src)` è¯»å–åˆ—è¡¨çš„ç¬¬ä¸€ä¸ªå…ƒç´ ã€‚
4. **é€’å½’å¤„ç†å‰©ä½™éƒ¨åˆ†**ï¼š
   - `rest = read_tail(src)` é€’å½’è°ƒç”¨ `read_tail` å‡½æ•°æ¥å¤„ç†åˆ—è¡¨çš„å‰©ä½™éƒ¨åˆ†ã€‚
5. **æ„é€  Pair**ï¼š
   - `return Pair(first, rest)` ä½¿ç”¨ `Pair` å¯¹è±¡å°†ç¬¬ä¸€ä¸ªå…ƒç´ å’Œå‰©ä½™éƒ¨åˆ†ç»„åˆæˆä¸€ä¸ªåˆ—è¡¨ã€‚

-----

## scals.py

`simplify`å‡½æ•°å¯ä»¥å°†å¯åŒ–ä¸ºæ•´æ•°çš„æµ®ç‚¹æ•°è½¬æ¢ä¸ºæ•´æ•°

```python
def simplify(value):
    """Return an int if value is an integer, or value otherwise.

    >>> simplify(8.0)
    8
    >>> simplify(2.3)
    2.3
    >>> simplify('+')
    '+'
    """
    if isinstance(value, float) and int(value) == value:
        return int(value)
    return value
```

`reduce`å‡½æ•°ï¼š

```python
def reduce(fn, scheme_list, start):
    """Reduce a recursive list of Pairs using fn and a start value.

    >>> reduce(add, as_scheme_list(1, 2, 3), 0)
    6
    """
    if scheme_list is nil:
        return start
    return reduce(fn, scheme_list.second, fn(start, scheme_list.first))
```

> `reduce` å‡½æ•°é€šè¿‡é€’å½’çš„æ–¹å¼ï¼Œå°† `scheme_list` ä¸­çš„å…ƒç´ ä¾æ¬¡ä¸ç´¯ç§¯ç»“æœè¿›è¡Œç»„åˆï¼Œæœ€ç»ˆè¿”å›ä¸€ä¸ªå•ä¸€çš„ç»“æœå€¼ã€‚è¿™ä¸ªå‡½æ•°æœ‰æ•ˆåœ°å®ç°äº†å¯¹é€’å½’åˆ—è¡¨çš„æŠ˜å æ“ä½œï¼Œç±»ä¼¼äº Python å†…ç½®çš„ `functools.reduce` å‡½æ•°ã€‚

`as_scheme_list`å‡½æ•°é€šè¿‡é€’å½’çš„æ–¹å¼å°†ä»»æ„æ•°é‡çš„å‚æ•°è½¬æ¢ä¸ºä¸€ä¸ª Scheme é£æ ¼çš„ `Pair` é“¾è¡¨

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œ==`*args`ä»£è¡¨å¯ä»¥ä¼ å…¥ä»»æ„æ•°é‡çš„å‚æ•°==

```python
def as_scheme_list(*args):
    """Return a recursive list of Pairs that contains the elements of args.

    >>> as_scheme_list(1, 2, 3)
    Pair(1, Pair(2, Pair(3, nil)))
    """
    if len(args) == 0:
        return nil
    return Pair(args[0], as_scheme_list(*args[1:]))
```

### Eval & Apply

```python linenums="1" hl_lines="12"
def calc_eval(exp):
    """Evaluate a Calculator expression.

    >>> calc_eval(as_scheme_list('+', 2, as_scheme_list('*', 4, 6)))
    26
    >>> calc_eval(as_scheme_list('+', 2, as_scheme_list('/', 40, 5)))
    10
    """
    if type(exp) in (int, float):
        return simplify(exp)
    elif isinstance(exp, Pair):
        arguments = exp.second.map(calc_eval)
        return simplify(calc_apply(exp.first, arguments))
    else:
        raise TypeError(str(exp) + ' is not a number or call expression')
```

é«˜äº®çš„è¯­å¥å®é™…ä¸Šæ˜¯é€’å½’ç›´åˆ°æ‰€æœ‰çš„å…ƒç´ éƒ½å®Œæˆè¯„ä¼°ï¼ˆç»“æŸåé‡Œé¢åªæœ‰è¿ç®—ç¬¦å’Œé“¾è¡¨ï¼‰ï¼Œä¹‹åä¼ ç»™`calc_apply`è¿›è¡Œåˆå¹¶è®¡ç®—ï¼š

```python
def calc_apply(operator, args):
    """Apply the named operator to a list of args.

    >>> calc_apply('+', as_scheme_list(1, 2, 3))
    6
    >>> calc_apply('-', as_scheme_list(10, 1, 2, 3))
    4
    >>> calc_apply('-', as_scheme_list(10))
    -10
    >>> calc_apply('*', nil)
    1
    >>> calc_apply('*', as_scheme_list(1, 2, 3, 4, 5))
    120
    >>> calc_apply('/', as_scheme_list(40, 5))
    8.0
    >>> calc_apply('/', as_scheme_list(10))
    0.1
    """
    if not isinstance(operator, str):
        raise TypeError(str(operator) + ' is not a symbol')
    if operator == '+':
        return reduce(add, args, 0)
    elif operator == '-':
        if len(args) == 0:
            raise TypeError(operator + ' requires at least 1 argument')
        elif len(args) == 1:
            return -args.first
        else:
            return reduce(sub, args.second, args.first)
    elif operator == '*':
        return reduce(mul, args, 1)
    elif operator == '/':
        if len(args) == 0:
            raise TypeError(operator + ' requires at least 1 argument')
        elif len(args) == 1:
            return 1/args.first
        else:
            return reduce(truediv, args.second, args.first)
    else:
        raise TypeError(operator + ' is an unknown operator')
```

å…¶ä¸­ç”¨åˆ°äº†å¾ˆå¤šæ¬¡`reduce`å‡½æ•°ï¼Œå°†`args`ï¼ˆå¤šä¸ªå‚æ•°ï¼‰è½¬åŒ–ä¸ºå•ä¸€çš„è®¡ç®—ç»“æœ

### read_eval_print_loop

è¿™ä¸ªå‡½æ•°æ˜¯ä¸€ä¸ªç®€å•çš„è¯»å–-è¯„ä¼°-æ‰“å°å¾ªç¯ (REPL)ï¼Œç”¨äºè®¡ç®—å™¨ç¨‹åºã€‚å®ƒæŒç»­è¯»å–ç”¨æˆ·è¾“å…¥çš„è¡¨è¾¾å¼ï¼Œè¯„ä¼°è¡¨è¾¾å¼ï¼Œç„¶åæ‰“å°ç»“æœ

```python
def buffer_input():
    return Buffer(tokenize_lines(InputReader('> ')))

@main
def read_eval_print_loop():
    """Run a read-eval-print loop for Calculator."""
    while True:
        try:
            src = buffer_input()
            while src.more_on_line:
                expression = scheme_read(src)
                print(calc_eval(expression))
        except (SyntaxError, TypeError, ValueError, ZeroDivisionError) as err:
            print(type(err).__name__ + ':', err)
        except (KeyboardInterrupt, EOFError):  # <Control>-D, etc.
            print('Calculation completed.')
            return
```

å‡è®¾æˆ‘ä»¬è¾“å…¥äº†ä»¥ä¸‹è¡¨è¾¾å¼ï¼š

```
(+ 1 2)
```

ç¨‹åºä¼šæŒ‰ç…§ä»¥ä¸‹é€»è¾‘æ‰§è¡Œï¼š

1. **è¯»å–è¾“å…¥**:
   - `buffer_input()` è¯»å–ç”¨æˆ·è¾“å…¥å¹¶ç”Ÿæˆ `Buffer` å¯¹è±¡ã€‚
   - `src.more_on_line` ç¡®è®¤å½“å‰è¡Œè¿˜æœ‰æ›´å¤šæ ‡è®°ã€‚
2. **è§£æå’Œè¯„ä¼°**:
   - `scheme_read(src)` å°†è¾“å…¥çš„å­—ç¬¦ä¸²è§£æä¸º Scheme è¡¨è¾¾å¼ï¼Œç»“æœä¸º `Pair('+', Pair(1, Pair(2, nil)))`ã€‚
   - `calc_eval(expression)` è¯„ä¼°è¿™ä¸ªè¡¨è¾¾å¼ï¼Œç»“æœä¸º `3`ã€‚
3. **æ‰“å°ç»“æœ**:
   - `print(3)` æ‰“å°è¯„ä¼°ç»“æœã€‚
4. **ç»§ç»­å¾ªç¯**:
   - å¾ªç¯ç»§ç»­ï¼Œç­‰å¾…ç”¨æˆ·è¾“å…¥ä¸‹ä¸€ä¸ªè¡¨è¾¾å¼ã€‚